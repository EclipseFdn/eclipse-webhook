<?php
/**
* Github model - provides functions for interacting with GitHub API
*/
if (file_exists('../config/projects_local.php')) {
  include('../config/projects_local.php');
} else {
  include('../config/projects.php');
}
include_once('../lib/restclient.php');
include_once('../lib/json_store.php');
include_once('../lib/status_store.php');

class GithubClient extends RestClient
{
  private $users;
  private $statusDetailsKey;
  
  /*
   * function: GithubClient::processRequest
   * @param string $request - json payload
   * @desc: dispatch request to appropriate handler.
   */
  public function processRequest($request) {
    $event = $_SERVER['HTTP_X_GITHUB_EVENT'];
    switch ($event) {
      case 'pull_request':
        $this->processPullRequest($request);
        break;
      case 'status':
        $this->processStatus($request);
        break;
      default:
      error_log('received unhandled github event: ' . $event);
        break;
    }
  }
  /*
   * function: GithubClient::processPullRequest
   * @param string $request - json payload
   * @desc: retrieves all referenced commits and checks authors for CLA.
   *       also checks that Signed-off-by header is present and matches committer.
   */
  public function processPullRequest($request) {
    //get repo commits
    $json = json_decode($request);
    error_log('handling pull request from '.$json->repository->full_name);
    error_log('action: '.$json->action);
    
    //don't do evaluation if pr is closing
    if ($json->action == 'close') { return; }
    
    $commits_url = $json->pull_request->url . '/commits';
    $statuses_url = $json->repository->statuses_url;
    error_log('commits url '.$commits_url);
    error_log('statuses url '.$statuses_url);
    
    //get commits
    $commits = $this->get($commits_url);
    error_log('number of commits: ' . count($commits));

    //walk authors, testing CLA and Signed-off-by
    $this->users = array(
      'validCLA' => array(),
      'invalidCLA' => array(),
      'unknownCLA' => array(),
      'validSignedOff' => array(),
      'invalidSignedOff' => array(),
      'unknownSignedOff' => array()
    );
    
    $previous_committers = array();
    for ($i=0; $i < count($commits); $i++) { 
      //TODO: evaluate author as well or instead?
      $committer = $commits[$i]->commit->committer;
      if (!in_array($committer->email, $previous_committers)) {
        $previous_committers[] = $committer->email;
        $this->evaluateCLA($committer);
        $this->evaluateSignature($commits[$i]->commit);
      }
      //if there is no login, the user given in the git commit is not a valid github user
      error_log('listed committer in commit: '.
        $commits[$i]->commit->committer->name .
        '<'.$commits[$i]->commit->committer->email.'>');
      
      //Signed-off-by is found in the commit message
      error_log('commit message: '.$commits[$i]->commit->message);      
    }
    
    //see if any problems were found, make suitable message
    $pullRequestState = $this->getPullRequestState();
    $pullRequestMessage = $this->composeStatusMessage();
    
    //get statuses (so we can provide history of 3rd party statuses)
    $status_history = $this->getCommitStatusHistory($statuses_url, end($commits));
    $this->users['StatusHistory'] = $status_history;
    
    //persist the status locally so it can be accessed at the github details url
    $this->storeStatus();
    
    //apply a new status to the pull request, targetting last commit.
    $result = $this->setCommitStatus($statuses_url, end($commits), $pullRequestState, $pullRequestMessage);
    
    //TODO: check if state of last history message is from a 3rd party and retain any error state in our status
    //TODO: close pull request?
    //TODO: email pull request originator
  }
  /*
   * function: GithubClient::processStatus
   * @param string $request - json payload
   * @desc: determines if the status event was generated by this service.
   *        if not, it revalidates users, sets status and includes status 
   *        history in the details report.
   */
  public function processStatus($request) {
    $json = json_decode($request);
    error_log('processing repo status update with target_url:' . $json->target_url);
    if(stripos(WEBHOOK_SERVICE_URL, $json->target_url) === FALSE) {
      //third party must have set status
      //TODO: get the pull request and re-evaluate
      //TODO: set a new status and add third party status history to details
    }
    //do nothing, status is already set.
  }
  /*
   * Function GithubClient::evaluateCLA
   * @param object committer - github user who made the commit
   * @desc evaluate CLA status against external service  
   */
  private function evaluateCLA($committer) {
    $email = $committer->email;
    $eclipse_cla_status = $this->curl_get($_SERVER['CLA_SERVICE']) . $email;
    if ($eclipse_cla_status == 'TRUE') {
      array_push($this->users['validCLA'], $email);
    } elseif ($eclipse_cla_status == 'FALSE') {
      array_push($this->users['invalidCLA'], $email);        
    } else {
      array_push($this->users['unknownCLA'], $email);
    }
  }
  
  /*
   * Function GithubClient::evaluateSignature
   * @param object commit
   * @desc evaluate signature match in Signed-off-by against committer
     @desc Signed-off-by is found in the commit message 
   */
  private function evaluateSignature($commit) {
    $email = $commit->committer->email;
    //look Signed-off-by pattern:
    $pattern = '/^Signed-off-by:.*<(.*@.*)>$/';
    //signature is only valid if it matches committer
    if (preg_match($pattern, $commit->message, $matches)) {
      if (count($matches) == 2) {
        if ($matches[1] == $email) {
          //matches committer
          array_push($this->users['validSignedOff'], $email);
        } else {
          //matched pattern but isn't the committer email
          array_push($this->users['invalidSignedOff'], $email);
        }
      }
      //matched pattern but there is more than one
      array_push($this->users['invalidSignedOff'], $email);
    } else {
      //no Signed-off-by at all
      array_push($this->users['unknownSignedOff'], $email);
    }
  }
  
  /*
   * Function GithubClient::getPullRequestState
   * @desc find the state for the entire message.
   * @return string expected by github status api
   */
  private function getPullRequestState() {
    if (count($this->users['invalidSignedOff']) +
        count($this->users['unknownSignedOff']) +
        count($this->users['invalidCLA']) +
        count($this->users['unknownCLA']) == 0) {
          return 'success';
    }
    return 'failure';
  }
  
  /*
   * Function GithubClient::storeStatus
   * @desc keep a record of the status to use in the details url on github
   */
  private function storeStatus() {
    $json_store = new JsonStore();
    $provider = new StatusStore($json_store);
  
    $this->statusDetailsKey = uniqid();
    return $provider->save($this->statusDetailsKey, $this->users); 
  }
  
  /*
   * Function GithubClient::composeStatusMessage
   * @desc build the status description including specific users and faults
   * @desc messages come from config/projects.php
   */
  private function composeStatusMessage() {
    global $messages;
    $parts = array();
    
    //list problems with corresponding users
    if (count($this->users['invalidCLA'])) {
      array_push($parts, $messages['badCLAs'] . implode(', ', $this->users['invalidCLA']));
    }
    if (count($this->users['unknownCLA'])) {
      array_push($parts, $messages['unknownUsers'] . implode(', ', $this->users['unknownCLA']));
    }
    if (count($this->users['invalidSignedOff'])) {
      array_push($parts, $messages['badSignatures'] . implode(', ', $this->users['invalidSignedOff']));
    }
    if (count($this->users['unknownSignedOff'])) {
      array_push($parts, $messages['badSignatures'] . implode(', ', $this->users['unknownSignedOff']));
    }
    //add a summary message
    if (count($parts)) {
      array_unshift($parts, $messages['failure']);
    } else {
      array_unshift($parts, $messages['success']);
    }
    
    return implode("\n", $parts);
  }
  
  /*
   * Function GithubClient::setCommitStatus
   * @param object commit - target commit for status
   * @param string state - the state to apply [success, failure, pending]
   * @param string message - comments to explain the status
   * @desc POSTs the status message and appearance on github 
   */
  private function setCommitStatus($url, $commit, $state, $message) {
    $url = str_replace('{sha}', $commit->sha, $url);
    error_log('pull request status update url: '. $url);
    
    //create a details url for the status message
    $service_url_parts = explode('/', WEBHOOK_SERVICE_URL);
    array_pop($service_url_parts);
    array_push($service_url_parts, 'status_details.php?id=' . $this->statusDetailsKey);
    $details_url = implode('/', $service_url_parts);
    
    //create payload required for github status post
    //see http://developer.github.com/v3/repos/statuses/#create-a-status
    $payload = null;
    $payload->state = $state;
    $payload->target_url = $details_url;
    
    //TODO: handle github description limit of 140 chars gracefully
    if (strlen($message) < 140) {
      $payload->description = $message;
    } else {
      $payload->description = substr($message, 0, 137) . '...';
    }
    
    return $this->post($url, $payload);
  }
  
  /*
   * Function GithubClient::getCommitStatusHistory
   * @param object commit - commit to query for status
   * @desc GETs the status messages
   */
  private function getCommitStatusHistory($url, $commit) {
    $result = array();
    $url = str_replace('{sha}', $commit->sha, $url);
    $json = $this->get($url);
    
    for ($i=0; $i < count($json); $i++) {
      $status = $json[$i];

      //record only 3rd party statuses, which won't match our details url
      $service_url_parts = explode('/', WEBHOOK_SERVICE_URL);
      array_pop($service_url_parts);
      if (stripos($status->target_url, implode('/', $service_url_parts)) !== 0) {
        $result[] = array(
          "url" => $status->url,
          "created_at" => $status->created_at,
          "description" => $status->description,
          "state" => $status->state,
          "target_url" => $status->target_url
        );
      }
    }
    return $result;
  }
}

?>
